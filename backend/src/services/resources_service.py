"""
Permission checks. if the user is allowed to play with the resources
"""

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, func
from ..database.models import Resources, ResourceType
from .group_service import is_user_in_group, can_manage_resources
from typing import Optional, List, Tuple

# ============================================================================
# PERMISSION CHECKS - The Foundation
# ============================================================================

async def can_user_view_resource(
        session: AsyncSession,
        user_id: str,
        resource_id: int
) -> bool:
    # first get the resource
    resource = await get_resource_by_id(session, resource_id)

    if not resource or resource.is_deleted:
        return False
    
    #rule 1: personal resource - only owner can view
    if resource.group_id is None:
        return resource.owner_id == user_id
    
    #rule 2: group resource - check if user is in group
    return await is_user_in_group(session, user_id, resource.group_id)

async def can_user_upload_resource(
        session: AsyncSession,
        user_id: str,
        group_id: Optional[int] 
) -> bool:
    # personal resource upload - always allowed
    if group_id is None:
        return True
    
    # group resource upload - check group permissions
    return await can_manage_resources(session, user_id, group_id)

async def can_user_modify_resource(
        session: AsyncSession,
        user_id: str,
        resource_id: int
) -> bool:
    # first get the resource
    resource = await get_resource_by_id(session, resource_id)

    if not resource or resource.is_deleted:
        return False
    
    #rule 1: personal resource - only owner can modify
    if resource.group_id is None:
        return resource.uploaded_by == user_id
    
    if resource.uploaded_by == user_id:
        return True
    
    #rule 2: group resource - check group permissions, This allows group admins to moderate content
    return await can_manage_resources(session, user_id, resource.group_id
)

# ============================================================================
# HELPER FUNCTION - Used by permission checks above
# ============================================================================

async def get_resource_by_id(
        session: AsyncSession,
        resource_id: int
) -> Optional[Resources]:
    result = await session.execute(
        select(Resources).where(
            and_(
            Resources.id == resource_id,
            Resources.is_deleted == False
            )
        )
    )
    return result.scalars().first()

"""
Resource Service Layer - Part 2: CRUD Operations"""


# ============================================================================
# CREATE - Making New Resources
# ============================================================================
async def create_resource(
        session: AsyncSession,
        user_id: str,
        title:str,
        url: str,
        resource_type: ResourceType,
        group_id: Optional[int] = None,
        description: Optional[str] = None,
        parent_folder_id: Optional[int] = None,
        file_size: Optional[int] = None
) -> Resources:
    # Create a new resource (personal or group)
    resource = Resources(
        uploaded_by=user_id,
        group_id=group_id,  # None or int
        title=title,
        url=url,
        resource_type=resource_type,
        description=description,
        parent_folder_id=parent_folder_id,
        file_size=file_size,
        is_deleted=False  # Explicit: not deleted
    )

    session.add(resource)
    await session.flush() # Flush to get the autogenerated ID 
    return resource

# ============================================================================
# READ - Getting Resources
# ============================================================================

async def get_personal_resources(
    session: AsyncSession,
    user_id: str,
    resource_type: Optional[ResourceType] = None,
    parent_folder_id: Optional[int] = None,
    search: Optional[str] = None,
    skip: int = 0,
    limit: int = 50
) -> Tuple[List[Resources], int]:
    # Build base query
    query = select(Resources).where(
        and_(
            Resources.uploaded_by == user_id,
            Resources.group_id == None,
            Resources.is_deleted == False
        )
    )

    # Apply optional filters
    if resource_type:
        query = query.where(Resources.resource_type == resource_type)
    if parent_folder_id is not None:
        query = query.where(Resources.parent_folder_id == parent_folder_id)
    if search:
        # Case-insensitive search in title
        search_pattern = f"%{search}%"
        query = query.where(Resources.title.ilike(search_pattern))

    # Count total matching resources (before pagination)
    count_query = select(func.count()).select_from(query.subquery())
    total_result = await session.execute(count_query)
    total = total_result.scalar_one()

    # Apply pagination and ordering
    query = query.order_by(
        Resources.created_at.desc()  # Newest first
    ).offset(skip).limit(limit)
    
    # Execute query
    result = await session.execute(query)
    resources = result.scalars().all()
    
    return list(resources), total

async def get_group_resources(
        session: AsyncSession,
        group_id: int,
        resource_type: Optional[ResourceType] = None,
        parent_folder_id: Optional[int] = None,
        search: Optional[str] = None,
        skip: int = 0,
        limit: int = 50
) -> Tuple[List[Resources], int]:
    # Similar to get_personal_resources but filters by group_id instead
    query = select(Resources).where(
        and_(
            Resources.group_id == group_id,
            Resources.is_deleted == False
        )
    )
    # Apply optional filters (same as personal)
    if resource_type:
        query = query.where(Resources.resource_type == resource_type)
    
    if parent_folder_id is not None:
        query = query.where(Resources.parent_folder_id == parent_folder_id)
    
    if search:
        query = query.where(Resources.title.ilike(f"%{search}%"))
    
    # Count total
    count_query = select(func.count()).select_from(query.subquery())
    total_result = await session.execute(count_query)
    total = total_result.scalar()
    
    # Pagination
    query = query.order_by(Resources.created_at.desc()).offset(skip).limit(limit)
    
    result = await session.execute(query)
    resources = result.scalars().all()
    
    return list(resources), total

# ============================================================================
# UPDATE - Modifying Existing Resources
# ============================================================================

async def update_resource(
        session: AsyncSession,
        resource_id: int,
        title: Optional[str] = None,
        description: Optional[str] = None,
        url: Optional[str] = None,
        parent_folder_id: Optional[int] = None
) -> Optional[Resources]:
    # get the resource
    resource = await get_resource_by_id(session, resource_id)

    if not resource:
        return None
    
    # Update fields if provided
    if title is not None:
        resource.title = title

    if description is not None:
        resource.description = description

    if url is not None:
        resource.url = url
    
    if parent_folder_id is not None:
        resource.parent_folder_id = parent_folder_id

    await session.flush()  # Ensure changes are saved

    return resource

# ============================================================================
# DELETE - Soft Delete (Not Permanent!)
# ============================================================================

async def delete_resource(
        session: AsyncSession,
        resource_id: int
) -> bool:
    # Soft delete the resource
    '''When to use hard delete?
    - Never in production (usually)
    - Maybe after 30 days in trash
    - Admin cleanup operations'''
    resource = await get_resource_by_id(session, resource_id)

    if not resource:
        return False
    
    #soft delete
    resource.is_deleted = True
    await session.flush()
    return True