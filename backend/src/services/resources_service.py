"""
Permission checks. if the user is allowed to play with the resources
"""

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_, func
from ..database.models import Resources, Groupings, InvitationStatus, ResourceType, ResourceProgress, ResourceStatus
from .group_service import is_user_in_group, can_manage_resources
from typing import Optional, List, Tuple
from datetime import datetime

# ============================================================================
# PERMISSION CHECKS - The Foundation
# ============================================================================

async def can_user_view_resource(
        session: AsyncSession,
        user_id: str,
        resource_id: int
) -> bool:
    # first get the resource
    resource = await get_resource_by_id(session, resource_id)

    if not resource or resource.is_deleted:
        return False
    
    #rule 1: personal resource - only owner can view
    if resource.group_id is None:
        return resource.owner_id == user_id
    
    #rule 2: group resource - check if user is in group
    return await is_user_in_group(session, user_id, resource.group_id)

async def can_user_upload_resource(
        session: AsyncSession,
        user_id: str,
        group_id: Optional[int] 
) -> bool:
    # personal resource upload - always allowed
    if group_id is None:
        return True
    
    # group resource upload - check group permissions
    return await can_manage_resources(session, user_id, group_id)

async def can_user_modify_resource(
        session: AsyncSession,
        user_id: str,
        resource_id: int
) -> bool:
    # first get the resource
    resource = await get_resource_by_id(session, resource_id)

    if not resource or resource.is_deleted:
        return False
    
    #rule 1: personal resource - only owner can modify
    if resource.group_id is None:
        return resource.uploaded_by == user_id
    
    if resource.uploaded_by == user_id:
        return True
    
    #rule 2: group resource - check group permissions, This allows group admins to moderate content
    return await can_manage_resources(session, user_id, resource.group_id
)

# ============================================================================
# HELPER FUNCTION - Used by permission checks above
# ============================================================================

async def get_resource_by_id(
        session: AsyncSession,
        resource_id: int
) -> Optional[Resources]:
    result = await session.execute(
        select(Resources).where(
            and_(
            Resources.id == resource_id,
            Resources.is_deleted == False
            )
        )
    )
    return result.scalars().first()

"""
Resource Service Layer - Part 2: CRUD Operations"""


# ============================================================================
# CREATE - Making New Resources
# ============================================================================
async def create_resource(
        session: AsyncSession,
        user_id: str,
        title:str,
        url: str,
        resource_type: ResourceType,
        group_id: Optional[int] = None,
        description: Optional[str] = None,
        parent_folder_id: Optional[int] = None,
        file_size: Optional[int] = None
) -> Resources:
    # Create a new resource (personal or group)
    resource = Resources(
        uploaded_by=user_id,
        group_id=group_id,  # None or int
        title=title,
        url=url,
        resource_type=resource_type,
        description=description,
        parent_folder_id=parent_folder_id,
        file_size=file_size,
        is_deleted=False  # Explicit: not deleted
    )

    session.add(resource)
    await session.flush() # Flush to get the autogenerated ID 
    return resource

# ============================================================================
# READ - Getting Resources
# ============================================================================

async def get_personal_resources(
    session: AsyncSession,
    user_id: str,
    resource_type: Optional[ResourceType] = None,
    parent_folder_id: Optional[int] = None,
    search: Optional[str] = None,
    skip: int = 0,
    limit: int = 50
) -> Tuple[List[Resources], int]:
    # Build base query
    query = select(Resources).where(
        and_(
            Resources.uploaded_by == user_id,
            Resources.group_id == None,
            Resources.is_deleted == False
        )
    )

    # Apply optional filters
    if resource_type:
        query = query.where(Resources.resource_type == resource_type)
    if parent_folder_id is not None:
        query = query.where(Resources.parent_folder_id == parent_folder_id)
    if search:
        # Case-insensitive search in title
        search_pattern = f"%{search}%"
        query = query.where(Resources.title.ilike(search_pattern))

    # Count total matching resources (before pagination)
    count_query = select(func.count()).select_from(query.subquery())
    total_result = await session.execute(count_query)
    total = total_result.scalar_one()

    # Apply pagination and ordering
    query = query.order_by(
        Resources.created_at.desc()  # Newest first
    ).offset(skip).limit(limit)
    
    # Execute query
    result = await session.execute(query)
    resources = result.scalars().all()
    
    return list(resources), total

async def get_group_resources(
        session: AsyncSession,
        group_id: int,
        resource_type: Optional[ResourceType] = None,
        parent_folder_id: Optional[int] = None,
        search: Optional[str] = None,
        skip: int = 0,
        limit: int = 50
) -> Tuple[List[Resources], int]:
    # Similar to get_personal_resources but filters by group_id instead
    query = select(Resources).where(
        and_(
            Resources.group_id == group_id,
            Resources.is_deleted == False
        )
    )
    # Apply optional filters (same as personal)
    if resource_type:
        query = query.where(Resources.resource_type == resource_type)
    
    if parent_folder_id is not None:
        query = query.where(Resources.parent_folder_id == parent_folder_id)
    
    if search:
        query = query.where(Resources.title.ilike(f"%{search}%"))
    
    # Count total
    count_query = select(func.count()).select_from(query.subquery())
    total_result = await session.execute(count_query)
    total = total_result.scalar()
    
    # Pagination
    query = query.order_by(Resources.created_at.desc()).offset(skip).limit(limit)
    
    result = await session.execute(query)
    resources = result.scalars().all()
    
    return list(resources), total

# ============================================================================
# UPDATE - Modifying Existing Resources
# ============================================================================

async def update_resource(
        session: AsyncSession,
        resource_id: int,
        title: Optional[str] = None,
        description: Optional[str] = None,
        url: Optional[str] = None,
        parent_folder_id: Optional[int] = None
) -> Optional[Resources]:
    # get the resource
    resource = await get_resource_by_id(session, resource_id)

    if not resource:
        return None
    
    # Update fields if provided
    if title is not None:
        resource.title = title

    if description is not None:
        resource.description = description

    if url is not None:
        resource.url = url
    
    if parent_folder_id is not None:
        resource.parent_folder_id = parent_folder_id

    await session.flush()  # Ensure changes are saved

    return resource

# ============================================================================
# DELETE - Soft Delete (Not Permanent!)
# ============================================================================

async def delete_resource(
        session: AsyncSession,
        resource_id: int
) -> bool:
    # Soft delete the resource
    '''When to use hard delete?
    - Never in production (usually)
    - Maybe after 30 days in trash
    - Admin cleanup operations'''
    resource = await get_resource_by_id(session, resource_id)

    if not resource:
        return False
    
    #soft delete
    resource.is_deleted = True
    await session.flush()
    return True

'''Part 3: Sharing and Advanced Features
   these handles:
- Sharing personal resources to groups
- Making group resources personal
- Getting all resources user can access
   '''

# ============================================================================
# Sharing operations: moving resources between contexts
# ===========================================================================

async def share_resource_to_group(
        session: AsyncSession,
        resource_id: int,
        group_id: int
) -> Optional[Resources]:
    # Share a personal resource to a group
    resource = await get_resource_by_id(session, resource_id)

    if not resource:
        return None
    
    # Only personal resources can be shared
    if resource.group_id is not None:
        return None
    
    resource.group_id = group_id
    await session.flush()
    return resource

async def make_resource_personal(
        session: AsyncSession,
        resource_id: int
) -> Optional[Resources]:
    # Make a group resource personal
    resource = await get_resource_by_id(session, resource_id)

    if not resource:
        return None
     
    #make it personal
    resource.group_id = None
    await session.flush()
    return resource

async def move_resource_to_group(
        session: AsyncSession,
        resource_id: int,
        target_group_id: int
) -> Optional[Resources]:
    # Move a resource to a different group
    resource = await get_resource_by_id(session, resource_id)

    if not resource:
        return None
    
    # move to target group
    resource.group_id = target_group_id
    await session.flush()
    return resource

# ============================================================================
# Advanced Read - Get all resources user can access
# ============================================================================

async def get_all_user_resources(
        session: AsyncSession,
        user_id: str,
        skip: int = 0,
        limit: int = 50
) -> Tuple[List[Resources], int]: 
    '''Why useful?
    - Dashboard "My Library" view
    - Search across everything
    - Recent resources feed'''

    #Step 1: Get all group IDs user belongs to
    group_result = await session.execute(
        select(Groupings.group_id).where(
            and_(
                Groupings.user_id == user_id,
                Groupings.invitation_status == InvitationStatus.ACCEPTED
            )
        )
    )
    user_group_ids = [row[0] for row in group_result.all()]

    #Step2: Build query for personal+groupresources
    query = select(Resources).where(
        and_(
            or_(
                # Personal resources (user's own)
                and_(
                    Resources.uploaded_by == user_id,
                    Resources.group_id == None
                ),
                # Group resources (from user's groups)
                Resources.group_id.in_(user_group_ids) if user_group_ids else False
            ),
            Resources.is_deleted == False
        )
    )

    # Step 3: Count total
    count_query = select(func.count()).select_from(query.subquery())
    total_result = await session.execute(count_query)
    total = total_result.scalar()
    
    # Step 4: Apply pagination
    query = query.order_by(
        Resources.created_at.desc()
    ).offset(skip).limit(limit)
    
    # Step 5: Execute
    result = await session.execute(query)
    resources = result.scalars().all()
    
    return list(resources), total

async def get_recent_resources(
        session: AsyncSession,
        user_id: str,
        limit: int = 10
) -> List[Resources]:
    # Get user's most recent resources (personal + groups)
    resources, _ = await get_all_user_resources(
        session=session,
        user_id=user_id,
        skip=0,
        limit=limit
    )
    
    return resources

# ============================================================================
# STATISTICS - Useful for Dashboards
# ============================================================================

async def get_user_resource_stats(
    session: AsyncSession,
    user_id: str
) -> dict:
    """    
    Use case:
        Dashboard widgets:
        "You have 23 personal resources"
        "42 resources shared in groups"
    
    Example:
        stats = await get_user_resource_stats(db, "user_123")
        
        # Returns:
        {
            "personal_count": 23,
            "group_count": 42,
            "total_count": 65,
            "by_type": {
                "video": 20,
                "file": 30,
                "link": 15
            },
            "added_this_week": 5
        }
    """
    
    from datetime import datetime, timedelta
    
    # Get all user's resources
    all_resources, total = await get_all_user_resources(
        session, user_id, skip=0, limit=10000  # Get all
    )
    
    # Count personal vs group
    personal_count = sum(1 for r in all_resources if r.group_id is None)
    group_count = sum(1 for r in all_resources if r.group_id is not None)
    
    # Count by type
    by_type = {}
    for resource in all_resources:
        type_name = resource.resource_type.value
        by_type[type_name] = by_type.get(type_name, 0) + 1
    
    # Count recent (last 7 days)
    week_ago = datetime.utcnow() - timedelta(days=7)
    added_this_week = sum(
        1 for r in all_resources 
        if r.created_at >= week_ago
    )
    
    return {
        "personal_count": personal_count,
        "group_count": group_count,
        "total_count": total,
        "by_type": by_type,
        "added_this_week": added_this_week
    }

"""
Resource Service Layer - Part 4: Progress Tracking (Pillar 2)
"""
# ============================================================================
# PROGRESS TRACKING - Pillar 2 Implementation
# ============================================================================

async def update_resource_progress(
        session: AsyncSession,
        user_id: str,
        resource_id: int,
        status: ResourceStatus,
        progress_percentage:int,
        notes: Optional[str] = None
) -> Optional[ResourceProgress]:
    #manula tracking - self reporting

    #try to find existing progress resord
    result = await session.execute(
        select(ResourceProgress).where(
            and_(
                ResourceProgress.user_id == user_id,
                ResourceProgress.resource_id == resource_id
            )
        )
    )
    progress = result.scalars().first()

    now = datetime.utcnow()

    #create new if doesn't exist
    if not progress:
        progrss = ResourceProgress(
            user_id=user_id,
            resource_id=resource_id,
            status=status,
            progress_percentage=progress_percentage,
            notes=notes,
            started_at=now if status != ResourceStatus.NOT_STARTED else None,
            completed_at=now if status == ResourceStatus.COMPLETED else None
        )
        session.add(progress)
    else:
        #update esisting
        progress.status = status
        progress.progress_percentage = progress_percentage

        if notes is not None:
            progress.notes = notes

        #smart timestamp update
        if status == ResourceStatus.IN_PROGRESS and not progress.started_at:#when progrss.started is empty
            progress.started_at = now

        if status == ResourceStatus.COMPLETED and not progress.completed_at:
            progress.completed_at = now
            progress.progress_percentage = 100

        await session.flush()

        return progress
    

async def get_resource_progress(
        session: AsyncSession,
        user_id: str,
        resource_id:int
) -> Optional[ResourceProgress]:
    #get user's progress on a specific record
    result = await session.execute(
        select(ResourceProgress).where(
            and_(
                ResourceProgress.user_id == user_id,
                ResourceProgress.resource_id == resource_id
            )
        )
    )
    return result.scalars().first()

async def get_all_user_progress(
        session: AsyncSession,
        user_id:str,
        status_filter: Optional[ResourceStatus] = None
) -> List[ResourceProgress]:
    #get all progress records for user
    ''' Use cases:
    - Dashboard: "5 resources in progress"
    - Achievements: "23 resources completed!"
    - Resume page: "Continue studying these"'''
    query = select(ResourceProgress).where(
        ResourceProgress.user_id == user_id
    )

    if status_filter:
        query = query.where(ResourceProgress.status == status_filter)

    #query by most recently updated first
    query = query.order_by(ResourceProgress.last_updated.desc())

    result = await session.execute(query)
    return result.scalars().all()

async def delete_resource_progress(
    session: AsyncSession,
    user_id: str,
    resource_id: int
) -> bool:
    #delste/reset user's progress on a resource

    result= await session.execute(
        select(ResourceProgress).where(
            and_(
                ResourceProgress.user_id == user_id,
                ResourceProgress.resource_id == resource_id
            )
        )
    )
    progress = result.scalars().first()

    if not progress:
        return False
    
    await session.delete(progress)
    await session.flush()

    return True

async def mark_resource_completed(
    session: AsyncSession,
    user_id: str,
    resource_id: int,
    notes: Optional[str] = None
) -> Optional[ResourceProgress]:
    '''Quick helper: Mark a resource as completed
    
    Convenience function that:
    - Sets status to COMPLETED
    - Sets progress to 100%
    - Records completion timestamp
    '''
    return await update_resource_progress(
        session=session,
        user_id=user_id,
        resource_id=resource_id,
        status=ResourceStatus.COMPLETED,
        progress_percentage=100,
        notes=notes
    )

async def mark_resource_started(
    session: AsyncSession,
    user_id: str,
    resource_id: int,
    notes: Optional[str] = None
) -> ResourceProgress:
    '''
    Quick helper: Mark a resource as started
    
    Convenience function that:
    - Sets status to IN_PROGRESS
    - Sets progress to 0% (just started)
    - Records start timestamp
    '''
    return await update_resource_progress(
        session=session,
        user_id=user_id,
        resource_id=resource_id,
        status=ResourceStatus.IN_PROGRESS,
        progress_percentage=0,
        notes=notes
    )

async def get_user_progress_stats(
    session: AsyncSession,
    user_id: str
) -> dict:
    """
    Get progress statistics for dashboards
    
    Returns counts by status:
    - How many in progress?
    - How many completed?
    - How many paused?
    - Completion rate
    
    Example response:
        {
            "not_started": 5,
            "in_progress": 12,
            "completed": 23,
            "paused": 3,
            "total_tracked": 43,
            "completion_rate": 53.5  # 23/43 = 53.5%
        }
    
    Use case:
        Dashboard widgets:
        "ğŸ“š 12 resources in progress"
        "âœ… 23 resources completed"
        "ğŸ¯ 53% completion rate"
    """
    
    all_progress = await get_all_user_progress(session, user_id)
    
    # Count by status
    by_status = {
        "not_started": 0,
        "in_progress": 0,
        "completed": 0,
        "paused": 0
    }
    
    for progress in all_progress:
        status_name = progress.status.value
        by_status[status_name] = by_status.get(status_name, 0) + 1
    
    total = len(all_progress)
    completed = by_status["completed"]
    completion_rate = (completed / total * 100) if total > 0 else 0
    
    return {
        "not_started": by_status["not_started"],
        "in_progress": by_status["in_progress"],
        "completed": by_status["completed"],
        "paused": by_status["paused"],
        "total_tracked": total,
        "completion_rate": round(completion_rate, 1)
    }


